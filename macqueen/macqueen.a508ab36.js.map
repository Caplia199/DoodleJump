{"mappings":"ACgBA,MAAM,EAGF,YAAY,CAAsB,CAAE,CAChC,IAAI,CAAC,MAAM,CAAG,EAAE,CAChB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAa,MAAM,CAAG,EAAG,IACzC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAM,CAAY,CAAC,EAAE,CAAE,CAAY,CAAC,EAAI,EAAE,EAEvE,CAEA,OAAO,YAAY,CAAqB,CAAE,CAAsB,CAAY,CACxE,IAAI,EAAU,EAAM,WAAW,CAAC,EAAa,EAAQ,MAAM,CAAC,EAAE,EAC9D,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAC,MAAM,CAAE,IACvC,EAAU,EAAM,WAAW,CAAC,EAAS,EAAQ,MAAM,CAAC,EAAE,EAE1D,OAAO,CACX,CAEA,OAAO,UAAU,CAAsB,CAAiB,CAEpD,IAAM,EAAa,IAAI,EACnB,EAAQ,MAAM,CAAC,GAAG,CAAC,AAAA,GAAK,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,EAAQ,MAAM,CAAC,EAAQ,MAAM,CAAC,MAAM,CAAG,EAAE,CAAC,OAAO,CAAC,MAAM,GAI5G,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAC,MAAM,CAAE,IACvC,EAAW,MAAM,CAAC,EAAE,CAAC,MAAM,CAAG,IAAI,EAAQ,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,CAC3D,EAAW,MAAM,CAAC,EAAE,CAAC,OAAO,CAAG,EAAQ,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,AAAA,GAAK,IAAI,EAAE,EAG5E,OAAO,CACX,CAEA,OAAO,OAAO,CAAsB,CAAE,EAAiB,EAAG,CAAE,CACxD,EAAQ,MAAM,CAAC,OAAO,CAAC,AAAA,QAvCjB,EAAA,EAwCF,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAC,MAAM,CAAE,IACrC,EAAM,MAAM,CAAC,EAAE,EAzCjB,EAyCyB,EAAM,MAAM,CAAC,EAAE,EAxCvC,AAAC,CAAA,AAwCwD,EAAhB,KAAK,MAAM,GAAS,EAxCxD,CAAA,EAwC2D,EAEnE,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,OAAO,CAAC,MAAM,CAAE,IACtC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,OAAO,CAAC,EAAE,CAAC,MAAM,CAAE,IACzC,EAAM,OAAO,CAAC,EAAE,CAAC,EAAE,EA7CzB,EA6CiC,EAAM,OAAO,CAAC,EAAE,CAAC,EAAE,EA5CnD,AAAC,CAAA,AA4CoE,EAAhB,KAAK,MAAM,GAAS,EA5CpE,CAAA,EA4CuE,CAGnF,EACJ,CACJ,CAEA,MAAM,EAMF,YAAY,CAAkB,CAAE,CAAmB,CAAE,CACjD,IAAI,CAAC,MAAM,CAAG,AAAI,MAAM,GACxB,IAAI,CAAC,OAAO,CAAG,AAAI,MAAM,GACzB,IAAI,CAAC,MAAM,CAAG,AAAI,MAAM,GACxB,IAAI,CAAC,OAAO,CAAG,MAAM,IAAI,CAAC,CAAE,OAAQ,CAAW,EAAG,IAAM,AAAI,MAAM,IAClE,EAAM,CAAA,CAAU,CAAC,IAAI,CACzB,CAEA,OAAO,CAAA,CAAU,CAAC,CAAY,EAC1B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAC,MAAM,CAAE,IACrC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,OAAO,CAAC,MAAM,CAAE,IACtC,EAAM,OAAO,CAAC,EAAE,CAAC,EAAE,CAAG,AAAgB,EAAhB,KAAK,MAAM,GAAS,EAGlD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAC,MAAM,CAAE,IACrC,EAAM,MAAM,CAAC,EAAE,CAAG,AAAgB,EAAhB,KAAK,MAAM,GAAS,CAE9C,CAEA,OAAO,YAAY,CAAqB,CAAE,CAAY,CAAY,CAC9D,EAAM,MAAM,CAAC,MAAM,CAAC,EAAG,EAAM,MAAM,CAAC,MAAM,IAAK,GAC/C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,OAAO,CAAC,MAAM,CAAE,IAAK,CAC3C,IAAI,EAAM,EACV,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAC,MAAM,CAAE,IACrC,GAAO,EAAM,MAAM,CAAC,EAAE,CAAG,EAAM,OAAO,CAAC,EAAE,CAAC,EAAE,AAEhD,CAAA,EAAM,OAAO,CAAC,EAAE,CAAG,CAAA,CAAA,EAAM,EAAM,MAAM,CAAC,EAAE,AAAF,CAC1C,CACA,OAAO,EAAM,OAAO,AACxB,CACJ,CAGA,MAAM,EAOF,YAAY,CAAa,CAAE,CAAc,CAAE,EAAgB,CAAC,CAAE,CAN9D,IAAA,CAAA,KAAA,CAAiB,EAAE,CACnB,IAAA,CAAA,KAAA,CAAiB,EAAE,CACnB,IAAA,CAAA,WAAA,CAA4B,EAAE,CAK1B,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,aAAa,CAAC,GACnB,IAAI,CAAC,mBAAmB,CAAC,EAC7B,CAEA,cAAc,CAAa,CAAE,CACrB,AAAU,IAAV,GAEA,IAAI,CAAC,KAAK,CAAG,CACT,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EACvD,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACvC,CACD,IAAI,CAAC,KAAK,CAAG,CACT,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACxC,EACgB,IAAV,IAEP,IAAI,CAAC,KAAK,CAAG,CACT,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACxD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACxD,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACvC,CACD,IAAI,CAAC,KAAK,CAAG,CACT,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACzD,CAAE,EAAG,IAAK,EAAG,GAAI,EAAG,CAAE,EAAG,IAAK,EAAG,GAAI,EACxC,CAET,CAEA,oBAAoB,CAAa,CAAE,CAC3B,AAAU,IAAV,EACA,IAAI,CAAC,WAAW,CAAG,CACf,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAChE,CACM,AAAU,IAAV,GACP,CAAA,IAAI,CAAC,WAAW,CAAG,CACf,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAC7D,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAAG,CAAE,EAAG,IAAK,EAAG,IAAK,OAAQ,EAAG,EAChE,AAAA,CAET,CACJ,CAGA,MAAM,EAgBF,YAAY,CAAS,CAAE,CAAS,CAAE,CAAa,CAAE,CAAqB,CAAE,CAVxE,IAAA,CAAA,KAAA,CAAiB,CAAA,EACjB,IAAA,CAAA,KAAA,CAAgB,EAChB,IAAA,CAAA,SAAA,CAAoB,EACpB,IAAA,CAAA,eAAA,CAA0B,EAC1B,IAAA,CAAA,IAAA,CAAe,EAEN,IAAA,CAAA,KAAA,CAAgB,GAChB,IAAA,CAAA,MAAA,CAAiB,GACjB,IAAA,CAAA,QAAA,CAAmB,EAGxB,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,KAAK,CAAG,GAAgB,IAAI,EAAc,CAAC,EAAG,EAAG,EAAE,CAC5D,CAEA,OAAO,CAAY,CAAW,CAC1B,GAAI,CAAC,IAAI,CAAC,KAAK,CAAE,MAAO,CAAA,CAExB,CAAA,IAAI,CAAC,KAAK,CAAG,IAEb,IAAM,EAAS,EAAM,WAAW,CAAC,IAAI,CAAC,eAAe,CAAG,EAAM,WAAW,CAAC,MAAM,CAAC,CAC3E,EAAW,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,CAAE,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,EAE1D,EAAY,KAAK,KAAK,CAAC,EAAO,CAAC,CAAG,IAAI,CAAC,CAAC,CAAE,EAAO,CAAC,CAAG,IAAI,CAAC,CAAC,EAC7D,EAAuB,IAAI,CAAC,KAAK,CAAG,EAExC,KAAO,EAAuB,KAAK,EAAE,EAAE,GAAwB,EAAI,KAAK,EAAE,CAC1E,KAAO,EAAuB,CAAC,KAAK,EAAE,EAAE,GAAwB,EAAI,KAAK,EAAE,CAE3E,IAAM,EAAS,CACX,EAAW,IACX,EAAuB,KAAK,EAAE,CACjC,CAEK,EAAO,AAAa,EAAb,AADG,EAAc,WAAW,CAAC,EAAQ,IAAI,CAAC,KAAK,CACxC,CAAC,EAAE,CAAO,EAU9B,OARA,IAAI,CAAC,KAAK,EAAI,IAAO,EAErB,IAAI,CAAC,CAAC,EAAI,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,EAAI,IAAI,CAAC,KAAK,CAC3C,IAAI,CAAC,CAAC,EAAI,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,EAAI,IAAI,CAAC,KAAK,CAE3C,IAAI,CAAC,SAAS,GAEd,IAAI,CAAC,cAAc,CAAC,GACb,IAAI,CAAC,gBAAgB,CAAC,EACjC,CAEA,eAAe,CAAY,CAAE,CACrB,CAAC,AA8Hb,SAA4B,CAAQ,CAAE,CAAY,EAE9C,IAAK,IAAM,KAAU,EAAI,UAAU,GAC/B,GAAI,CAAC,EAAe,EAAQ,EAAM,KAAK,GAAK,EAAe,EAAQ,EAAM,KAAK,EAC1E,MAAO,CAAA,EAGf,MAAO,CAAA,CACX,EAtIgC,IAAI,CAAE,IAC1B,CAAA,IAAI,CAAC,KAAK,CAAG,CAAA,CADjB,CAGJ,CAEA,iBAAiB,CAAY,CAAW,CACpC,GAAI,CAAC,IAAI,CAAC,KAAK,CAAE,MAAO,CAAA,EACxB,IAAM,EAAS,EAAM,WAAW,CAAC,IAAI,CAAC,eAAe,CAAG,EAAM,WAAW,CAAC,MAAM,CAAC,OAEjF,EAAI,CAAA,AADa,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,CAAE,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,EACjD,EAAO,MAAM,AAAN,IAClB,IAAI,CAAC,eAAe,GACpB,IAAI,CAAC,SAAS,CAAG,IAEb,CAAA,IAAI,CAAC,eAAe,EAAI,EAAM,WAAW,CAAC,MAAM,AAAN,KAC1C,IAAI,CAAC,IAAI,GACT,IAAI,CAAC,eAAe,CAAG,EAChB,CAAA,EAInB,CAEA,WAAW,CAAY,CAAU,CAC7B,IAAM,EAAc,IAAI,CAAC,eAAe,CAAG,EAAM,WAAW,CAAC,MAAM,CAC7D,EAAS,EAAM,WAAW,CAAC,EAAY,CACvC,EAAc,AAAC,CAAA,IAAI,CAAC,eAAe,CAAG,EAAI,EAAM,WAAW,CAAC,MAAM,AAAN,EAAU,EAAM,WAAW,CAAC,MAAM,CAC9F,EAAS,EAAM,WAAW,CAAC,EAAY,CAEvC,EAAc,KAAK,KAAK,CAAC,EAAO,CAAC,CAAG,EAAO,CAAC,CAAE,EAAO,CAAC,CAAG,EAAO,CAAC,EAGjE,EAAW,KAAK,GAAG,CAAC,EAAG,EAFR,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,CAAE,IAAI,CAAC,CAAC,CAAG,EAAO,CAAC,GAGhE,EAAU,IAAK,CAAC,eAAe,CAAG,EAAe,EAQrD,OANA,GAAY,AAAiB,GAAjB,IAAI,CAAC,SAAS,CAEtB,AAAC,IAAI,CAAC,KAAK,EACX,CAAA,GAAW,GADf,EAIO,CACX,CAEA,YAAsB,CAClB,IAAM,EAAM,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,EAAI,EAC5C,EAAQ,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,EAC1C,EAAK,CAAE,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAG,GAAS,EAAK,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAG,GAAS,CAAI,EACtG,EAAK,CAAE,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAG,GAAS,EAAK,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAG,GAAS,CAAI,EAG5G,MAAO,CAAC,EAAI,EAFD,CAAE,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,KAAK,EAAE,CAAG,IAAI,CAAC,KAAK,CAAG,GAAS,EAAK,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,KAAK,EAAE,CAAG,IAAI,CAAC,KAAK,CAAG,GAAS,CAAI,EACrH,CAAE,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,KAAK,EAAE,CAAG,IAAI,CAAC,KAAK,CAAG,GAAS,EAAK,EAAG,IAAI,CAAC,CAAC,CAAG,KAAK,GAAG,CAAC,KAAK,EAAE,CAAG,IAAI,CAAC,KAAK,CAAG,GAAS,CAAI,EACzG,AAC3B,CACJ,CA6DA,SAAS,EAAe,CAAY,CAAE,CAAgB,EAClD,IAAI,EAAW,CAAA,EACf,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAG,EAAG,EAAI,EAAQ,MAAM,CAAE,EAAI,IAAK,CACjE,IAAM,EAAK,CAAO,CAAC,EAAE,CAAC,CAAC,CAAE,EAAK,CAAO,CAAC,EAAE,CAAC,CAAC,CACpC,EAAK,CAAO,CAAC,EAAE,CAAC,CAAC,CAAE,EAAK,CAAO,CAAC,EAAE,CAAC,CAAC,AAItC,CAFgB,EAAK,EAAM,CAAC,EAAO,EAAK,EAAM,CAAC,EAC3C,EAAM,CAAC,CAAI,AAAA,CAAA,EAAK,CAAA,EAAO,CAAA,EAAM,CAAC,CAAG,CAAA,EAAO,CAAA,EAAK,CAAA,EAAM,GAC5C,CAAA,EAAW,CAAC,CAA3B,CACJ,CACA,OAAO,CACX,CAaA,MAAM,EAeF,YAAY,CAAyB,CAAE,CAXvC,IAAA,CAAA,IAAA,CAAc,EAAE,CAChB,IAAA,CAAA,OAAA,CAAsB,KACtB,IAAA,CAAA,cAAA,CAAyB,EACzB,IAAA,CAAA,eAAA,CAA0B,EAC1B,IAAA,CAAA,OAAA,CAAmB,CAAA,EACnB,IAAA,CAAA,WAAA,CAAsB,EACtB,IAAA,CAAA,UAAA,CAAqB,EACrB,IAAA,CAAA,YAAA,CAAuB,EACvB,IAAA,CAAA,SAAA,CAAoB,EACpB,IAAA,CAAA,SAAA,CAAoB,EAGhB,IAAI,CAAC,MAAM,CAAG,EACd,IAAI,CAAC,GAAG,CAAG,EAAO,UAAU,CAAC,MAC7B,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,EAAO,KAAK,CAAE,EAAO,MAAM,CAAE,IAAI,CAAC,YAAY,EACrE,IAAI,CAAC,MAAM,EACf,CAEA,QAAS,CACL,SAAS,cAAc,CAAC,aAAc,gBAAgB,CAAC,QAAS,IAAM,IAAI,CAAC,KAAK,IAChF,SAAS,cAAc,CAAC,aAAc,gBAAgB,CAAC,QAAS,IAAM,IAAI,CAAC,SAAS,GACxF,CAEA,OAAQ,CACA,IAAI,CAAC,OAAO,GAEhB,SAAS,cAAc,CAAC,aAAc,KAAK,CAAC,OAAO,CAAG,OACtD,SAAS,cAAc,CAAC,aAAc,KAAK,CAAC,OAAO,CAAG,eAEtD,IAAI,CAAC,SAAS,CAAC,CAAA,GACnB,CAEA,UAAU,EAAoB,CAAA,CAAI,CAAE,CAChC,IAAI,CAAC,OAAO,CAAG,CAAA,EACZ,IAAI,CAAC,WAAW,EAAE,qBAAqB,IAAI,CAAC,WAAW,EAE1D,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,UAAU,CAAG,EAClB,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,SAAS,CAAG,KAAK,GAAG,GAErB,GACA,aAAa,UAAU,CAAC,kBAAoB,IAAI,CAAC,YAAY,EAGjE,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,YAAY,EAC/E,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,uBAAuB,GACxC,IAAI,CAAC,eAAe,CAAG,EAEvB,IAAM,EAAc,aAAa,OAAO,CAAC,kBAAoB,IAAI,CAAC,YAAY,EAC9E,GAAI,EAAa,CACb,QAAQ,GAAG,CAAC,4CAA6C,IAAI,CAAC,YAAY,EAC1E,IAAM,EAAY,KAAK,KAAK,CAAC,EAC7B,CAAA,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAG,EACrB,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,IAAI,CAAC,EAAE,AAC/B,CAEA,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,OAAO,EAChB,CAEA,yBAAiC,CAC7B,IAAM,EAAc,EAAE,CAChB,EAAW,IAAI,CAAC,gBAAgB,GACtC,IAAK,IAAI,EAAI,EAAG,EAAI,IAAI,CAAC,cAAc,CAAE,IACrC,EAAK,IAAI,CAAC,IAAI,EAAI,EAAS,CAAC,CAAE,EAAS,CAAC,CAAE,EAAS,KAAK,GAG5D,OADA,IAAI,CAAC,eAAe,CAAG,EAChB,CACX,CAEA,gBAAiB,CACb,IAAI,CAAC,UAAU,GAEf,IAAM,EAA0B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAG,IAAM,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK,EAAI,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK,EAAI,EAAI,GAEjH,GACA,IAAI,CAAC,OAAO,CAAG,IAAI,EAAI,EAAE,EAAE,EAAG,EAAwB,KAAK,EAC3D,aAAa,OAAO,CAAC,kBAAoB,IAAI,CAAC,YAAY,CAAE,KAAK,SAAS,CAAC,EAAwB,KAAK,GAExG,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,uBAAuB,GAExC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAG,EAAc,SAAS,CAAC,EAAwB,KAAK,EAC1E,EAAc,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAE,KAGzC,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,uBAAuB,GAE5C,IAAI,CAAC,eAAe,CAAG,CAC3B,CAEA,SAAU,CACN,GAAI,CAAC,IAAI,CAAC,OAAO,CAAE,OAEnB,IAAM,EAAa,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAGlD,GAFqB,EAAW,MAAM,CAAC,IAAI,CAAC,KAAK,EAE/B,CACd,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,uBAAuB,CAAC,KACzB,IAAI,CAAC,SAAS,CAAC,EAAW,KAAK,EAC/B,IAAI,CAAC,OAAO,CAAG,CAAA,EACf,IAAI,CAAC,OAAO,EAChB,GACA,MACJ,CAEI,CAAC,EAAW,KAAK,GACjB,IAAI,CAAC,eAAe,GAChB,IAAI,CAAC,eAAe,EAAI,IAAI,CAAC,IAAI,CAAC,MAAM,EACxC,IAAI,CAAC,cAAc,IAI3B,IAAI,CAAC,QAAQ,GAEb,IAAI,CAAC,MAAM,GACX,IAAI,CAAC,WAAW,CAAG,sBAAsB,IAAM,IAAI,CAAC,OAAO,GAC/D,CAEA,kBAA4D,CACxD,GAAI,AAAsB,IAAtB,IAAI,CAAC,YAAY,CACjB,MAAO,CAAE,EAAG,IAAK,EAAG,IAAK,MAAO,CAAE,EAC/B,GAAI,AAAsB,IAAtB,IAAI,CAAC,YAAY,CACxB,MAAO,CAAE,EAAG,IAAK,EAAG,IAAK,MAAO,CAAE,CAEtC,OAAM,AAAI,MAAM,gBACpB,CAEA,QAAS,CAIL,GAHA,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAG,EAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM,EAC9D,IAAI,CAAC,WAAW,GAEZ,IAAI,CAAC,eAAe,EAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAE,OAC9C,IAAM,EAAa,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAElD,IAAI,CAAC,GAAG,CAAC,IAAI,GACb,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,EAAI,KAChC,IAAM,EAAc,EAAW,eAAe,CAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAE9E,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAG,CAAC,CAAE,EAAG,CAAC,CAAE,EAAG,MAAM,CAAE,EAAG,AAAU,EAAV,KAAK,EAAE,EAC9C,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EAEjB,EAAQ,EAAW,eAAe,EAClC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,uBACvB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,wBACd,IAAU,GACjB,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,uBACvB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,2BAErB,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,2BACvB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,4BAEzB,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAC,IAAI,GAEb,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,QACrB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAG,aAChB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,SACrB,IAAI,CAAC,GAAG,CAAC,YAAY,CAAG,SACxB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAQ,QAAQ,GAAI,EAAG,CAAC,CAAE,EAAG,CAAC,CACpD,GACA,IAAI,CAAC,GAAG,CAAC,OAAO,GAEhB,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,GACvB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,AAAA,IACV,EAAI,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,EAClC,GACA,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,EAEnB,GAAc,EAAW,KAAK,EAC9B,IAAI,CAAC,SAAS,CAAC,EAEvB,CAEA,aAAc,CASV,IAAK,IAAM,KARX,IAAI,CAAC,GAAG,CAAC,IAAI,GACb,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,OACvB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EACrB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,OAGrB,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,EAC5B,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EAK5B,IAAK,IAAM,KAHX,IAAI,CAAC,GAAG,CAAC,SAAS,GAElB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,EAC5B,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EAS5B,IAAK,IAAM,KAPX,IAAI,CAAC,GAAG,CAAC,SAAS,GAElB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAGd,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,EAC5B,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EAM5B,IAAK,IAAM,KAJX,IAAI,CAAC,GAAG,CAAC,MAAM,GAEf,IAAI,CAAC,GAAG,CAAC,SAAS,GAClB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAC5C,IAAI,CAAC,KAAK,CAAC,KAAK,EAC5B,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,EAE5B,IAAI,CAAC,GAAG,CAAC,MAAM,GAGf,IAAI,CAAC,GAAG,CAAC,WAAW,CAAG,OACvB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,GACrB,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,GAAI,GAAG,EAC7B,IAAI,CAAC,GAAG,CAAC,SAAS,GACd,AAAsB,IAAtB,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAK,KACrB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAK,MACQ,IAAtB,IAAI,CAAC,YAAY,GACxB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAK,KACrB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAK,MAEzB,IAAI,CAAC,GAAG,CAAC,MAAM,GAEf,IAAI,CAAC,GAAG,CAAC,OAAO,EACpB,CAEA,UAAU,CAAQ,CAAE,CAChB,IAAI,CAAC,GAAG,CAAC,IAAI,GACb,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAI,CAAC,CAAE,EAAI,CAAC,EAC/B,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAI,KAAK,EACzB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,EAAI,KAAK,CAAG,UAAY,UAC7C,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAI,KAAK,CAAG,EAAG,CAAC,EAAI,MAAM,CAAG,EAAG,EAAI,KAAK,CAAE,EAAI,MAAM,EACxE,IAAI,CAAC,GAAG,CAAC,OAAO,EACpB,CAEA,UAAW,CACN,SAAS,cAAc,CAAC,SAAyB,WAAW,CAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,GACzF,SAAS,cAAc,CAAC,cAA8B,WAAW,CAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,GAE7F,IAAM,EAA0B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAG,IAAM,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK,EAAI,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK,EAAI,EAAI,GAGrH,GAFC,SAAS,cAAc,CAAC,cAA8B,WAAW,CAAG,EAAwB,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC,GAExH,IAAI,CAAC,eAAe,CAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAE,CACzC,IAAM,EAAa,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,AAC9C,CAAA,GACA,CAAA,SAAU,cAAc,CAAC,SAAyB,WAAW,CAAG,EAAW,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC,EAD9G,CAGJ,CAEC,SAAS,cAAc,CAAC,kBAAkC,WAAW,CAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,GAChG,IAAM,EAAc,KAAK,KAAK,CAAE,AAAA,CAAA,KAAK,GAAG,GAAK,IAAI,CAAC,SAAQ,AAAR,EAAa,IAC9D,CAAA,SAAS,cAAc,CAAC,cAA8B,WAAW,CAAG,CAAA,EAAG,EAAY,OAAC,CAAC,AAC1F,CAEA,wBAAwB,CAAoB,CAAE,CAC1C,IAAM,EAAS,SAAS,cAAc,CAAC,wBACvC,CAAA,EAAO,KAAK,CAAC,OAAO,CAAG,QACvB,WAAW,KACP,EAAO,KAAK,CAAC,OAAO,CAAG,OACvB,GACJ,EAAG,IACP,CAEA,UAAU,CAA2B,CAAE,CAKnC,GAJA,IAAI,CAAC,SAAS,GACd,IAAI,CAAC,YAAY,GACjB,IAAI,CAAC,UAAU,CAAG,EAEd,IAAI,CAAC,YAAY,CAAG,EAAG,CACvB,MAAM,sCACN,IAAI,CAAC,SAAS,CAAC,CAAA,GACf,MACJ,CAEA,aAAa,OAAO,CAAC,kBAAoB,IAAI,CAAC,YAAY,CAAE,KAAK,SAAS,CAAC,IAE3E,IAAI,CAAC,KAAK,CAAG,IAAI,EAAM,IAAI,CAAC,MAAM,CAAC,KAAK,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,IAAI,CAAC,YAAY,EAC/E,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,uBAAuB,GACxC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAG,EAAc,SAAS,CAAC,GAC7C,EAAc,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAE,IAEzC,IAAI,CAAC,eAAe,CAAG,EACvB,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,IAAI,CAAC,EAAE,AAC/B,CACJ,CAGA,SAAS,gBAAgB,CAAC,mBAAoB,KAC1C,IAAM,EAAS,SAAS,cAAc,CAAC,aACnC,CAAA,GACa,IAAI,EAAK,EAE9B","sources":["<anon>","src/main.ts"],"sourcesContent":["var $ad2bcec7a0192558$exports = {};\n// --- Типы данных ---\n// --- Утилиты ---\nfunction $ad2bcec7a0192558$var$lerp(a, b, t) {\n    return a + (b - a) * t;\n}\n// --- Нейронная сеть ---\nclass $ad2bcec7a0192558$var$NeuralNetwork {\n    constructor(neuronCounts){\n        this.levels = [];\n        for(let i = 0; i < neuronCounts.length - 1; i++)this.levels.push(new $ad2bcec7a0192558$var$Level(neuronCounts[i], neuronCounts[i + 1]));\n    }\n    static feedForward(givenInputs, network) {\n        let outputs = $ad2bcec7a0192558$var$Level.feedForward(givenInputs, network.levels[0]);\n        for(let i = 1; i < network.levels.length; i++)outputs = $ad2bcec7a0192558$var$Level.feedForward(outputs, network.levels[i]);\n        return outputs;\n    }\n    static replicate(network) {\n        // Создаем новую сеть с такой же архитектурой\n        const newNetwork = new $ad2bcec7a0192558$var$NeuralNetwork(network.levels.map((l)=>l.inputs.length).concat(network.levels[network.levels.length - 1].outputs.length));\n        // Глубоко копируем веса и смещения\n        for(let i = 0; i < network.levels.length; i++){\n            newNetwork.levels[i].biases = [\n                ...network.levels[i].biases\n            ];\n            newNetwork.levels[i].weights = network.levels[i].weights.map((w)=>[\n                    ...w\n                ]);\n        }\n        return newNetwork;\n    }\n    static mutate(network, amount = 0.1) {\n        network.levels.forEach((level)=>{\n            for(let i = 0; i < level.biases.length; i++)level.biases[i] = $ad2bcec7a0192558$var$lerp(level.biases[i], Math.random() * 2 - 1, amount);\n            for(let i = 0; i < level.weights.length; i++)for(let j = 0; j < level.weights[i].length; j++)level.weights[i][j] = $ad2bcec7a0192558$var$lerp(level.weights[i][j], Math.random() * 2 - 1, amount);\n        });\n    }\n}\nclass $ad2bcec7a0192558$var$Level {\n    constructor(inputCount, outputCount){\n        this.inputs = new Array(inputCount);\n        this.outputs = new Array(outputCount);\n        this.biases = new Array(outputCount);\n        this.weights = Array.from({\n            length: inputCount\n        }, ()=>new Array(outputCount));\n        $ad2bcec7a0192558$var$Level.#randomize(this);\n    }\n    static #randomize(level) {\n        for(let i = 0; i < level.inputs.length; i++)for(let j = 0; j < level.outputs.length; j++)level.weights[i][j] = Math.random() * 2 - 1;\n        for(let i = 0; i < level.biases.length; i++)level.biases[i] = Math.random() * 2 - 1;\n    }\n    static feedForward(givenInputs, level) {\n        level.inputs.splice(0, level.inputs.length, ...givenInputs);\n        for(let i = 0; i < level.outputs.length; i++){\n            let sum = 0;\n            for(let j = 0; j < level.inputs.length; j++)sum += level.inputs[j] * level.weights[j][i];\n            level.outputs[i] = sum > level.biases[i] ? 1 : 0; // Step activation\n        }\n        return level.outputs;\n    }\n}\n// --- Класс трассы ---\nclass $ad2bcec7a0192558$var$Track {\n    constructor(width, height, level = 1){\n        this.outer = [];\n        this.inner = [];\n        this.checkpoints = [];\n        this.width = width;\n        this.height = height;\n        this.generateTrack(level);\n        this.generateCheckpoints(level);\n    }\n    generateTrack(level) {\n        if (level === 1) {\n            // Уровень 1: Плавный овал\n            this.outer = [\n                {\n                    x: 150,\n                    y: 100\n                },\n                {\n                    x: 650,\n                    y: 100\n                },\n                {\n                    x: 725,\n                    y: 175\n                },\n                {\n                    x: 750,\n                    y: 300\n                },\n                {\n                    x: 725,\n                    y: 425\n                },\n                {\n                    x: 650,\n                    y: 500\n                },\n                {\n                    x: 150,\n                    y: 500\n                },\n                {\n                    x: 75,\n                    y: 425\n                },\n                {\n                    x: 50,\n                    y: 300\n                },\n                {\n                    x: 75,\n                    y: 175\n                },\n                {\n                    x: 150,\n                    y: 100\n                }\n            ];\n            this.inner = [\n                {\n                    x: 250,\n                    y: 200\n                },\n                {\n                    x: 550,\n                    y: 200\n                },\n                {\n                    x: 625,\n                    y: 250\n                },\n                {\n                    x: 650,\n                    y: 300\n                },\n                {\n                    x: 625,\n                    y: 350\n                },\n                {\n                    x: 550,\n                    y: 400\n                },\n                {\n                    x: 250,\n                    y: 400\n                },\n                {\n                    x: 175,\n                    y: 350\n                },\n                {\n                    x: 150,\n                    y: 300\n                },\n                {\n                    x: 175,\n                    y: 250\n                },\n                {\n                    x: 250,\n                    y: 200\n                }\n            ];\n        } else if (level === 2) {\n            // Уровень 2: Более извилистая трасса\n            this.outer = [\n                {\n                    x: 100,\n                    y: 100\n                },\n                {\n                    x: 400,\n                    y: 50\n                },\n                {\n                    x: 700,\n                    y: 100\n                },\n                {\n                    x: 750,\n                    y: 300\n                },\n                {\n                    x: 700,\n                    y: 500\n                },\n                {\n                    x: 400,\n                    y: 550\n                },\n                {\n                    x: 100,\n                    y: 500\n                },\n                {\n                    x: 50,\n                    y: 400\n                },\n                {\n                    x: 150,\n                    y: 300\n                },\n                {\n                    x: 50,\n                    y: 200\n                },\n                {\n                    x: 100,\n                    y: 100\n                }\n            ];\n            this.inner = [\n                {\n                    x: 200,\n                    y: 200\n                },\n                {\n                    x: 350,\n                    y: 150\n                },\n                {\n                    x: 600,\n                    y: 200\n                },\n                {\n                    x: 650,\n                    y: 300\n                },\n                {\n                    x: 600,\n                    y: 400\n                },\n                {\n                    x: 450,\n                    y: 450\n                },\n                {\n                    x: 300,\n                    y: 400\n                },\n                {\n                    x: 250,\n                    y: 350\n                },\n                {\n                    x: 350,\n                    y: 300\n                },\n                {\n                    x: 250,\n                    y: 250\n                },\n                {\n                    x: 200,\n                    y: 200\n                }\n            ];\n        }\n    }\n    generateCheckpoints(level) {\n        if (level === 1) this.checkpoints = [\n            {\n                x: 400,\n                y: 150,\n                radius: 30\n            },\n            {\n                x: 650,\n                y: 150,\n                radius: 30\n            },\n            {\n                x: 700,\n                y: 300,\n                radius: 30\n            },\n            {\n                x: 650,\n                y: 450,\n                radius: 30\n            },\n            {\n                x: 400,\n                y: 450,\n                radius: 30\n            },\n            {\n                x: 150,\n                y: 450,\n                radius: 30\n            },\n            {\n                x: 100,\n                y: 300,\n                radius: 30\n            },\n            {\n                x: 150,\n                y: 150,\n                radius: 30\n            }\n        ];\n        else if (level === 2) this.checkpoints = [\n            {\n                x: 400,\n                y: 100,\n                radius: 25\n            },\n            {\n                x: 650,\n                y: 150,\n                radius: 25\n            },\n            {\n                x: 700,\n                y: 300,\n                radius: 25\n            },\n            {\n                x: 650,\n                y: 450,\n                radius: 25\n            },\n            {\n                x: 400,\n                y: 500,\n                radius: 25\n            },\n            {\n                x: 150,\n                y: 450,\n                radius: 25\n            },\n            {\n                x: 100,\n                y: 300,\n                radius: 25\n            },\n            {\n                x: 200,\n                y: 225,\n                radius: 25\n            },\n            {\n                x: 400,\n                y: 200,\n                radius: 25\n            },\n            {\n                x: 550,\n                y: 300,\n                radius: 25\n            },\n            {\n                x: 450,\n                y: 400,\n                radius: 25\n            },\n            {\n                x: 300,\n                y: 325,\n                radius: 25\n            }\n        ];\n    }\n}\n// --- Класс машинки ---\nclass $ad2bcec7a0192558$var$Car {\n    constructor(x, y, angle, brain){\n        this.alive = true;\n        this.score = 0;\n        this.timeAlive = 0;\n        this.checkpointIndex = 0;\n        this.laps = 0;\n        this.width = 20;\n        this.height = 30;\n        this.maxSpeed = 5;\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.speed = 0;\n        this.brain = brain ? brain : new $ad2bcec7a0192558$var$NeuralNetwork([\n            2,\n            6,\n            1\n        ]);\n    }\n    update(track) {\n        if (!this.alive) return false;\n        this.speed = 2.5;\n        const nextCp = track.checkpoints[this.checkpointIndex % track.checkpoints.length];\n        const distToCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        const angleToCp = Math.atan2(nextCp.y - this.y, nextCp.x - this.x);\n        let carAngleRelativeToCp = this.angle - angleToCp;\n        while(carAngleRelativeToCp > Math.PI)carAngleRelativeToCp -= 2 * Math.PI;\n        while(carAngleRelativeToCp < -Math.PI)carAngleRelativeToCp += 2 * Math.PI;\n        const inputs = [\n            distToCp / 300,\n            carAngleRelativeToCp / Math.PI\n        ];\n        const outputs = $ad2bcec7a0192558$var$NeuralNetwork.feedForward(inputs, this.brain);\n        const turn = outputs[0] * 2 - 1;\n        this.angle += 0.03 * turn;\n        this.x += Math.cos(this.angle) * this.speed;\n        this.y += Math.sin(this.angle) * this.speed;\n        this.timeAlive++;\n        this.checkCollision(track);\n        return this.checkCheckpoints(track);\n    }\n    checkCollision(track) {\n        if (!$ad2bcec7a0192558$var$isPointInsideTrack(this, track)) this.alive = false;\n    }\n    checkCheckpoints(track) {\n        if (!this.alive) return false;\n        const nextCp = track.checkpoints[this.checkpointIndex % track.checkpoints.length];\n        const distToCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        if (distToCp < nextCp.radius) {\n            this.checkpointIndex++;\n            this.timeAlive = 0;\n            if (this.checkpointIndex >= track.checkpoints.length) {\n                this.laps++;\n                this.checkpointIndex = 0;\n                return true; // Lap completed\n            }\n        }\n        return false; // Lap not completed\n    }\n    getFitness(track) {\n        const nextCpIndex = this.checkpointIndex % track.checkpoints.length;\n        const nextCp = track.checkpoints[nextCpIndex];\n        const prevCpIndex = (this.checkpointIndex - 1 + track.checkpoints.length) % track.checkpoints.length;\n        const prevCp = track.checkpoints[prevCpIndex];\n        const totalCpDist = Math.hypot(nextCp.x - prevCp.x, nextCp.y - prevCp.y);\n        const distToNextCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        const progress = Math.max(0, totalCpDist - distToNextCp);\n        let fitness = this.checkpointIndex * totalCpDist + progress;\n        fitness -= this.timeAlive * 0.1;\n        if (!this.alive) fitness -= 100;\n        return fitness;\n    }\n    getCorners() {\n        const rad = Math.hypot(this.width, this.height) / 2;\n        const alpha = Math.atan2(this.width, this.height);\n        const p1 = {\n            x: this.x - Math.sin(this.angle - alpha) * rad,\n            y: this.y + Math.cos(this.angle - alpha) * rad\n        };\n        const p2 = {\n            x: this.x - Math.sin(this.angle + alpha) * rad,\n            y: this.y + Math.cos(this.angle + alpha) * rad\n        };\n        const p3 = {\n            x: this.x - Math.sin(Math.PI + this.angle - alpha) * rad,\n            y: this.y - Math.cos(Math.PI + this.angle - alpha) * rad\n        };\n        const p4 = {\n            x: this.x - Math.sin(Math.PI + this.angle + alpha) * rad,\n            y: this.y - Math.cos(Math.PI + this.angle + alpha) * rad\n        };\n        return [\n            p1,\n            p2,\n            p3,\n            p4\n        ];\n    }\n}\n// --- Простейший ИИ ---\nclass $ad2bcec7a0192558$var$SimpleAI {\n    // На вход: сенсоры, на выход: {acc, turn}\n    decide(sensors) {\n        // Простая логика: если впереди свободно — газуем, иначе тормозим и поворачиваем\n        const front = sensors[2];\n        const left = sensors[1];\n        const right = sensors[3];\n        let acc = front > 0.3 ? 1 : -1;\n        let turn = 0;\n        if (left < right && left < 0.5) turn = 1;\n        else if (right < left && right < 0.5) turn = -1;\n        return {\n            acc: acc,\n            turn: turn\n        };\n    }\n}\n// --- Сенсоры ---\nfunction $ad2bcec7a0192558$var$getSensors(car, track) {\n    const sensorAngles = [\n        -90,\n        -45,\n        0,\n        45,\n        90\n    ];\n    const result = [];\n    for (let a of sensorAngles){\n        const angle = car.angle + a * Math.PI / 180;\n        result.push($ad2bcec7a0192558$var$getDistanceToBoundary(car.x, car.y, angle, track));\n    }\n    return result;\n}\nfunction $ad2bcec7a0192558$var$getDistanceToBoundary(x, y, angle, track) {\n    // Луч до пересечения с границей (упрощённо: только внешняя граница)\n    const rayLength = 200;\n    let minDist = rayLength;\n    for(let i = 0; i < track.outer.length - 1; i++){\n        const p1 = track.outer[i];\n        const p2 = track.outer[i + 1];\n        const dist = $ad2bcec7a0192558$var$lineIntersection(x, y, x + Math.cos(angle) * rayLength, y + Math.sin(angle) * rayLength, p1.x, p1.y, p2.x, p2.y);\n        if (dist > 0 && dist < minDist) minDist = dist;\n    }\n    for(let i = 0; i < track.inner.length - 1; i++){\n        const p1 = track.inner[i];\n        const p2 = track.inner[i + 1];\n        const dist = $ad2bcec7a0192558$var$lineIntersection(x, y, x + Math.sin(angle) * rayLength, y - Math.cos(angle) * rayLength, p1.x, p1.y, p2.x, p2.y);\n        if (dist > 0 && dist < minDist) minDist = dist;\n    }\n    return minDist / rayLength;\n}\nfunction $ad2bcec7a0192558$var$lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (den === 0) return -1;\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);\n    }\n    return -1;\n}\nfunction $ad2bcec7a0192558$var$pointInPolygon(point, polygon) {\n    let isInside = false;\n    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n        const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\nfunction $ad2bcec7a0192558$var$isPointInsideTrack(car, track) {\n    // Проверяем все 4 угла машины\n    for (const corner of car.getCorners()){\n        if (!$ad2bcec7a0192558$var$pointInPolygon(corner, track.outer) || $ad2bcec7a0192558$var$pointInPolygon(corner, track.inner)) return false;\n    }\n    return true;\n}\n// --- Основная логика ---\nclass $ad2bcec7a0192558$var$Game {\n    constructor(canvas){\n        this.cars = [];\n        this.bestCar = null;\n        this.populationSize = 1;\n        this.currentCarIndex = 0;\n        this.running = false;\n        this.animationId = 0;\n        this.generation = 1;\n        this.currentLevel = 1;\n        this.totalLaps = 0;\n        this.startTime = 0;\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.track = new $ad2bcec7a0192558$var$Track(canvas.width, canvas.height, this.currentLevel);\n        this.initUI();\n    }\n    initUI() {\n        document.getElementById('start-btn').addEventListener('click', ()=>this.start());\n        document.getElementById('reset-btn').addEventListener('click', ()=>this.resetGame());\n    }\n    start() {\n        if (this.running) return;\n        document.getElementById('start-btn').style.display = 'none';\n        document.getElementById('reset-btn').style.display = 'inline-block';\n        this.resetGame(false); // Не сбрасываем localStorage при старте\n    }\n    resetGame(clearLocalStorage = true) {\n        this.running = false;\n        if (this.animationId) cancelAnimationFrame(this.animationId);\n        this.currentLevel = 1;\n        this.generation = 1;\n        this.totalLaps = 0;\n        this.startTime = Date.now();\n        if (clearLocalStorage) localStorage.removeItem(\"bestBrain_level\" + this.currentLevel);\n        this.track = new $ad2bcec7a0192558$var$Track(this.canvas.width, this.canvas.height, this.currentLevel);\n        this.cars = this.createInitialPopulation();\n        this.currentCarIndex = 0;\n        const storedBrain = localStorage.getItem(\"bestBrain_level\" + this.currentLevel);\n        if (storedBrain) {\n            console.log(\"Loading brain from localStorage for level\", this.currentLevel);\n            const bestBrain = JSON.parse(storedBrain);\n            this.cars[0].brain = bestBrain;\n            this.bestCar = this.cars[0];\n        }\n        this.running = true;\n        this.animate();\n    }\n    createInitialPopulation() {\n        const cars = [];\n        const startPos = this.getStartPosition();\n        for(let i = 0; i < this.populationSize; i++)cars.push(new $ad2bcec7a0192558$var$Car(startPos.x, startPos.y, startPos.angle));\n        this.currentCarIndex = 0;\n        return cars;\n    }\n    nextGeneration() {\n        this.generation++;\n        const bestCarOfLastGeneration = this.cars.reduce((a, b)=>a.getFitness(this.track) > b.getFitness(this.track) ? a : b);\n        if (bestCarOfLastGeneration) {\n            this.bestCar = new $ad2bcec7a0192558$var$Car(0, 0, 0, bestCarOfLastGeneration.brain);\n            localStorage.setItem(\"bestBrain_level\" + this.currentLevel, JSON.stringify(bestCarOfLastGeneration.brain));\n            this.cars = this.createInitialPopulation();\n            this.cars[0].brain = $ad2bcec7a0192558$var$NeuralNetwork.replicate(bestCarOfLastGeneration.brain);\n            $ad2bcec7a0192558$var$NeuralNetwork.mutate(this.cars[0].brain, 0.2);\n        } else this.cars = this.createInitialPopulation();\n        this.currentCarIndex = 0;\n    }\n    animate() {\n        if (!this.running) return;\n        const currentCar = this.cars[this.currentCarIndex];\n        const lapCompleted = currentCar.update(this.track);\n        if (lapCompleted) {\n            this.running = false; // Pause the game\n            this.showLevelCompleteBanner(()=>{\n                this.nextLevel(currentCar.brain);\n                this.running = true;\n                this.animate();\n            });\n            return;\n        }\n        if (!currentCar.alive) {\n            this.currentCarIndex++;\n            if (this.currentCarIndex >= this.cars.length) this.nextGeneration();\n        }\n        this.updateUI();\n        this.render();\n        this.animationId = requestAnimationFrame(()=>this.animate());\n    }\n    getStartPosition() {\n        if (this.currentLevel === 1) return {\n            x: 170,\n            y: 150,\n            angle: 0\n        };\n        else if (this.currentLevel === 2) return {\n            x: 150,\n            y: 150,\n            angle: 0\n        };\n        throw new Error(\"Invalid level\");\n    }\n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.renderTrack();\n        if (this.currentCarIndex >= this.cars.length) return;\n        const currentCar = this.cars[this.currentCarIndex];\n        this.ctx.save();\n        this.track.checkpoints.forEach((cp, index)=>{\n            const nextCpIndex = currentCar.checkpointIndex % this.track.checkpoints.length;\n            this.ctx.beginPath();\n            this.ctx.arc(cp.x, cp.y, cp.radius, 0, Math.PI * 2);\n            this.ctx.lineWidth = 2;\n            if (index < currentCar.checkpointIndex) {\n                this.ctx.strokeStyle = \"rgba(0, 255, 0, 0.8)\";\n                this.ctx.fillStyle = \"rgba(0, 255, 0, 0.3)\";\n            } else if (index === nextCpIndex) {\n                this.ctx.strokeStyle = \"rgba(255, 255, 0, 1)\";\n                this.ctx.fillStyle = \"rgba(255, 255, 0, 0.4)\";\n            } else {\n                this.ctx.strokeStyle = \"rgba(255, 255, 255, 0.5)\";\n                this.ctx.fillStyle = \"rgba(255, 255, 255, 0.1)\";\n            }\n            this.ctx.stroke();\n            this.ctx.fill();\n            this.ctx.fillStyle = \"white\";\n            this.ctx.font = \"12px Arial\";\n            this.ctx.textAlign = \"center\";\n            this.ctx.textBaseline = \"middle\";\n            this.ctx.fillText(index.toString(), cp.x, cp.y);\n        });\n        this.ctx.restore();\n        this.ctx.globalAlpha = 0.2;\n        this.cars.forEach((car)=>{\n            if (car.alive) this.renderCar(car);\n        });\n        this.ctx.globalAlpha = 1;\n        if (currentCar && currentCar.alive) this.renderCar(currentCar);\n    }\n    renderTrack() {\n        this.ctx.save();\n        this.ctx.strokeStyle = '#fff';\n        this.ctx.lineWidth = 5;\n        this.ctx.fillStyle = '#888'; // Цвет дороги\n        // Рисуем внешнюю и внутреннюю границы и заливаем пространство между ними\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.outer[0].x, this.track.outer[0].y);\n        for (const p of this.track.outer)this.ctx.lineTo(p.x, p.y);\n        this.ctx.closePath();\n        this.ctx.moveTo(this.track.inner[0].x, this.track.inner[0].y);\n        for (const p of this.track.inner)this.ctx.lineTo(p.x, p.y);\n        this.ctx.closePath();\n        this.ctx.fill('evenodd');\n        // Рисуем белые линии границ\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.outer[0].x, this.track.outer[0].y);\n        for (const p of this.track.outer)this.ctx.lineTo(p.x, p.y);\n        this.ctx.stroke();\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.inner[0].x, this.track.inner[0].y);\n        for (const p of this.track.inner)this.ctx.lineTo(p.x, p.y);\n        this.ctx.stroke();\n        // Рисуем стартовую линию\n        this.ctx.strokeStyle = '#fff';\n        this.ctx.lineWidth = 10;\n        this.ctx.setLineDash([\n            10,\n            10\n        ]);\n        this.ctx.beginPath();\n        if (this.currentLevel === 1) {\n            this.ctx.moveTo(200, 100);\n            this.ctx.lineTo(200, 200);\n        } else if (this.currentLevel === 2) {\n            this.ctx.moveTo(150, 100);\n            this.ctx.lineTo(150, 200);\n        }\n        this.ctx.stroke();\n        this.ctx.restore();\n    }\n    renderCar(car) {\n        this.ctx.save();\n        this.ctx.translate(car.x, car.y);\n        this.ctx.rotate(car.angle);\n        this.ctx.fillStyle = car.alive ? '#3498db' : '#e74c3c';\n        this.ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);\n        this.ctx.restore();\n    }\n    updateUI() {\n        document.getElementById('level').textContent = this.currentLevel.toString();\n        document.getElementById('generation').textContent = this.generation.toString();\n        const bestCarOfLastGeneration = this.cars.reduce((a, b)=>a.getFitness(this.track) > b.getFitness(this.track) ? a : b);\n        document.getElementById('best-score').textContent = bestCarOfLastGeneration.getFitness(this.track).toFixed(0);\n        if (this.currentCarIndex < this.cars.length) {\n            const currentCar = this.cars[this.currentCarIndex];\n            if (currentCar) document.getElementById('score').textContent = currentCar.getFitness(this.track).toFixed(0);\n        }\n        document.getElementById('laps-completed').textContent = this.totalLaps.toString();\n        const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);\n        document.getElementById('total-time').textContent = `${elapsedTime}\\u{441}`;\n    }\n    showLevelCompleteBanner(callback) {\n        const banner = document.getElementById('level-complete-banner');\n        banner.style.display = 'block';\n        setTimeout(()=>{\n            banner.style.display = 'none';\n            callback();\n        }, 3000); // Show for 3 seconds\n    }\n    nextLevel(fittestBrain) {\n        this.totalLaps++;\n        this.currentLevel++;\n        this.generation = 1;\n        if (this.currentLevel > 2) {\n            alert(\"\\u041F\\u043E\\u0437\\u0434\\u0440\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C! \\u0412\\u044B \\u043F\\u0440\\u043E\\u0448\\u043B\\u0438 \\u0432\\u0441\\u0435 \\u0443\\u0440\\u043E\\u0432\\u043D\\u0438!\");\n            this.resetGame(true);\n            return;\n        }\n        localStorage.setItem(\"bestBrain_level\" + this.currentLevel, JSON.stringify(fittestBrain));\n        this.track = new $ad2bcec7a0192558$var$Track(this.canvas.width, this.canvas.height, this.currentLevel);\n        this.cars = this.createInitialPopulation();\n        this.cars[0].brain = $ad2bcec7a0192558$var$NeuralNetwork.replicate(fittestBrain);\n        $ad2bcec7a0192558$var$NeuralNetwork.mutate(this.cars[0].brain, 0.3);\n        this.currentCarIndex = 0;\n        this.bestCar = this.cars[0];\n    }\n}\n// --- Запуск ---\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    const canvas = document.getElementById('gameCanvas');\n    if (canvas) {\n        const game = new $ad2bcec7a0192558$var$Game(canvas);\n    }\n});\n\n\n//# sourceMappingURL=macqueen.a508ab36.js.map\n","// --- Типы данных ---\ninterface Point {\n    x: number;\n    y: number;\n}\n\ninterface Checkpoint extends Point {\n    radius: number;\n}\n\n// --- Утилиты ---\nfunction lerp(a: number, b: number, t: number): number {\n    return a + (b - a) * t;\n}\n\n// --- Нейронная сеть ---\nclass NeuralNetwork {\n    levels: Level[];\n\n    constructor(neuronCounts: number[]) {\n        this.levels = [];\n        for (let i = 0; i < neuronCounts.length - 1; i++) {\n            this.levels.push(new Level(neuronCounts[i], neuronCounts[i + 1]));\n        }\n    }\n\n    static feedForward(givenInputs: number[], network: NeuralNetwork): number[] {\n        let outputs = Level.feedForward(givenInputs, network.levels[0]);\n        for (let i = 1; i < network.levels.length; i++) {\n            outputs = Level.feedForward(outputs, network.levels[i]);\n        }\n        return outputs;\n    }\n\n    static replicate(network: NeuralNetwork): NeuralNetwork {\n        // Создаем новую сеть с такой же архитектурой\n        const newNetwork = new NeuralNetwork(\n            network.levels.map(l => l.inputs.length).concat(network.levels[network.levels.length - 1].outputs.length)\n        );\n        \n        // Глубоко копируем веса и смещения\n        for (let i = 0; i < network.levels.length; i++) {\n            newNetwork.levels[i].biases = [...network.levels[i].biases];\n            newNetwork.levels[i].weights = network.levels[i].weights.map(w => [...w]);\n        }\n        \n        return newNetwork;\n    }\n\n    static mutate(network: NeuralNetwork, amount: number = 0.1) {\n        network.levels.forEach(level => {\n            for (let i = 0; i < level.biases.length; i++) {\n                level.biases[i] = lerp(level.biases[i], Math.random() * 2 - 1, amount);\n            }\n            for (let i = 0; i < level.weights.length; i++) {\n                for (let j = 0; j < level.weights[i].length; j++) {\n                    level.weights[i][j] = lerp(level.weights[i][j], Math.random() * 2 - 1, amount);\n                }\n            }\n        });\n    }\n}\n\nclass Level {\n    inputs: number[];\n    outputs: number[];\n    biases: number[];\n    weights: number[][];\n\n    constructor(inputCount: number, outputCount: number) {\n        this.inputs = new Array(inputCount);\n        this.outputs = new Array(outputCount);\n        this.biases = new Array(outputCount);\n        this.weights = Array.from({ length: inputCount }, () => new Array(outputCount));\n        Level.#randomize(this);\n    }\n\n    static #randomize(level: Level) {\n        for (let i = 0; i < level.inputs.length; i++) {\n            for (let j = 0; j < level.outputs.length; j++) {\n                level.weights[i][j] = Math.random() * 2 - 1;\n            }\n        }\n        for (let i = 0; i < level.biases.length; i++) {\n            level.biases[i] = Math.random() * 2 - 1;\n        }\n    }\n\n    static feedForward(givenInputs: number[], level: Level): number[] {\n        level.inputs.splice(0, level.inputs.length, ...givenInputs);\n        for (let i = 0; i < level.outputs.length; i++) {\n            let sum = 0;\n            for (let j = 0; j < level.inputs.length; j++) {\n                sum += level.inputs[j] * level.weights[j][i];\n            }\n            level.outputs[i] = sum > level.biases[i] ? 1 : 0; // Step activation\n        }\n        return level.outputs;\n    }\n}\n\n// --- Класс трассы ---\nclass Track {\n    outer: Point[] = [];\n    inner: Point[] = [];\n    checkpoints: Checkpoint[] = [];\n    width: number;\n    height: number;\n\n    constructor(width: number, height: number, level: number = 1) {\n        this.width = width;\n        this.height = height;\n        this.generateTrack(level);\n        this.generateCheckpoints(level);\n    }\n\n    generateTrack(level: number) {\n        if (level === 1) {\n            // Уровень 1: Плавный овал\n            this.outer = [\n                { x: 150, y: 100 }, { x: 650, y: 100 }, { x: 725, y: 175 },\n                { x: 750, y: 300 }, { x: 725, y: 425 }, { x: 650, y: 500 },\n                { x: 150, y: 500 }, { x: 75, y: 425 }, { x: 50, y: 300 },\n                { x: 75, y: 175 }, { x: 150, y: 100 }\n            ];\n            this.inner = [\n                { x: 250, y: 200 }, { x: 550, y: 200 }, { x: 625, y: 250 },\n                { x: 650, y: 300 }, { x: 625, y: 350 }, { x: 550, y: 400 },\n                { x: 250, y: 400 }, { x: 175, y: 350 }, { x: 150, y: 300 },\n                { x: 175, y: 250 }, { x: 250, y: 200 }\n            ];\n        } else if (level === 2) {\n            // Уровень 2: Более извилистая трасса\n            this.outer = [\n                { x: 100, y: 100 }, { x: 400, y: 50 }, { x: 700, y: 100 },\n                { x: 750, y: 300 }, { x: 700, y: 500 }, { x: 400, y: 550 },\n                { x: 100, y: 500 }, { x: 50, y: 400 }, { x: 150, y: 300 },\n                { x: 50, y: 200 }, { x: 100, y: 100 }\n            ];\n            this.inner = [\n                { x: 200, y: 200 }, { x: 350, y: 150 }, { x: 600, y: 200 },\n                { x: 650, y: 300 }, { x: 600, y: 400 }, { x: 450, y: 450 },\n                { x: 300, y: 400 }, { x: 250, y: 350 }, { x: 350, y: 300 },\n                { x: 250, y: 250 }, { x: 200, y: 200 }\n            ];\n        }\n    }\n\n    generateCheckpoints(level: number) {\n        if (level === 1) {\n            this.checkpoints = [\n                { x: 400, y: 150, radius: 30 }, { x: 650, y: 150, radius: 30 },\n                { x: 700, y: 300, radius: 30 }, { x: 650, y: 450, radius: 30 },\n                { x: 400, y: 450, radius: 30 }, { x: 150, y: 450, radius: 30 },\n                { x: 100, y: 300, radius: 30 }, { x: 150, y: 150, radius: 30 }\n            ];\n        } else if (level === 2) {\n            this.checkpoints = [\n                { x: 400, y: 100, radius: 25 }, { x: 650, y: 150, radius: 25 },\n                { x: 700, y: 300, radius: 25 }, { x: 650, y: 450, radius: 25 },\n                { x: 400, y: 500, radius: 25 }, { x: 150, y: 450, radius: 25 },\n                { x: 100, y: 300, radius: 25 }, { x: 200, y: 225, radius: 25 },\n                { x: 400, y: 200, radius: 25 }, { x: 550, y: 300, radius: 25 },\n                { x: 450, y: 400, radius: 25 }, { x: 300, y: 325, radius: 25 }\n            ];\n        }\n    }\n}\n\n// --- Класс машинки ---\nclass Car {\n    x: number;\n    y: number;\n    angle: number;\n    speed: number;\n    brain: NeuralNetwork;\n    alive: boolean = true;\n    score: number = 0;\n    timeAlive: number = 0;\n    checkpointIndex: number = 0;\n    laps: number = 0;\n    \n    readonly width: number = 20;\n    readonly height: number = 30;\n    readonly maxSpeed: number = 5;\n\n    constructor(x: number, y: number, angle: number, brain?: NeuralNetwork) {\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.speed = 0;\n        this.brain = brain ? brain : new NeuralNetwork([2, 6, 1]);\n    }\n\n    update(track: Track): boolean {\n        if (!this.alive) return false;\n        \n        this.speed = 2.5;\n\n        const nextCp = track.checkpoints[this.checkpointIndex % track.checkpoints.length];\n        const distToCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        \n        const angleToCp = Math.atan2(nextCp.y - this.y, nextCp.x - this.x);\n        let carAngleRelativeToCp = this.angle - angleToCp;\n\n        while (carAngleRelativeToCp > Math.PI) carAngleRelativeToCp -= 2 * Math.PI;\n        while (carAngleRelativeToCp < -Math.PI) carAngleRelativeToCp += 2 * Math.PI;\n\n        const inputs = [\n            distToCp / 300, \n            carAngleRelativeToCp / Math.PI\n        ];\n        const outputs = NeuralNetwork.feedForward(inputs, this.brain);\n        const turn = outputs[0] * 2 - 1;\n\n        this.angle += 0.03 * turn;\n\n        this.x += Math.cos(this.angle) * this.speed;\n        this.y += Math.sin(this.angle) * this.speed;\n\n        this.timeAlive++;\n        \n        this.checkCollision(track);\n        return this.checkCheckpoints(track);\n    }\n    \n    checkCollision(track: Track) {\n        if (!isPointInsideTrack(this, track)) {\n            this.alive = false;\n        }\n    }\n\n    checkCheckpoints(track: Track): boolean {\n        if (!this.alive) return false;\n        const nextCp = track.checkpoints[this.checkpointIndex % track.checkpoints.length];\n        const distToCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        if (distToCp < nextCp.radius) {\n            this.checkpointIndex++;\n            this.timeAlive = 0;\n\n            if (this.checkpointIndex >= track.checkpoints.length) {\n                this.laps++;\n                this.checkpointIndex = 0;\n                return true; // Lap completed\n            }\n        }\n        return false; // Lap not completed\n    }\n\n    getFitness(track: Track): number {\n        const nextCpIndex = this.checkpointIndex % track.checkpoints.length;\n        const nextCp = track.checkpoints[nextCpIndex];\n        const prevCpIndex = (this.checkpointIndex - 1 + track.checkpoints.length) % track.checkpoints.length;\n        const prevCp = track.checkpoints[prevCpIndex];\n\n        const totalCpDist = Math.hypot(nextCp.x - prevCp.x, nextCp.y - prevCp.y);\n        const distToNextCp = Math.hypot(this.x - nextCp.x, this.y - nextCp.y);\n        \n        const progress = Math.max(0, totalCpDist - distToNextCp);\n        let fitness = (this.checkpointIndex * totalCpDist) + progress;\n\n        fitness -= (this.timeAlive * 0.1);\n\n        if (!this.alive) {\n            fitness -= 100;\n        }\n\n        return fitness;\n    }\n\n    getCorners(): Point[] {\n        const rad = Math.hypot(this.width, this.height) / 2;\n        const alpha = Math.atan2(this.width, this.height);\n        const p1 = { x: this.x - Math.sin(this.angle - alpha) * rad, y: this.y + Math.cos(this.angle - alpha) * rad };\n        const p2 = { x: this.x - Math.sin(this.angle + alpha) * rad, y: this.y + Math.cos(this.angle + alpha) * rad };\n        const p3 = { x: this.x - Math.sin(Math.PI + this.angle - alpha) * rad, y: this.y - Math.cos(Math.PI + this.angle - alpha) * rad };\n        const p4 = { x: this.x - Math.sin(Math.PI + this.angle + alpha) * rad, y: this.y - Math.cos(Math.PI + this.angle + alpha) * rad };\n        return [p1, p2, p3, p4];\n    }\n}\n\n// --- Простейший ИИ ---\nclass SimpleAI {\n    // На вход: сенсоры, на выход: {acc, turn}\n    decide(sensors: number[]): {acc: number, turn: number} {\n        // Простая логика: если впереди свободно — газуем, иначе тормозим и поворачиваем\n        const front = sensors[2];\n        const left = sensors[1];\n        const right = sensors[3];\n        let acc = front > 0.3 ? 1 : -1;\n        let turn = 0;\n        if (left < right && left < 0.5) turn = 1;\n        else if (right < left && right < 0.5) turn = -1;\n        return {acc, turn};\n    }\n}\n\n// --- Сенсоры ---\nfunction getSensors(car: Car, track: Track): number[] {\n    const sensorAngles = [-90, -45, 0, 45, 90];\n    const result: number[] = [];\n    for (let a of sensorAngles) {\n        const angle = car.angle + (a * Math.PI) / 180;\n        result.push(getDistanceToBoundary(car.x, car.y, angle, track));\n    }\n    return result;\n}\n\nfunction getDistanceToBoundary(x: number, y: number, angle: number, track: Track): number {\n    // Луч до пересечения с границей (упрощённо: только внешняя граница)\n    const rayLength = 200;\n    let minDist = rayLength;\n    for (let i = 0; i < track.outer.length - 1; i++) {\n        const p1 = track.outer[i];\n        const p2 = track.outer[i + 1];\n        const dist = lineIntersection(x, y, x + Math.cos(angle) * rayLength, y + Math.sin(angle) * rayLength, p1.x, p1.y, p2.x, p2.y);\n        if (dist > 0 && dist < minDist) minDist = dist;\n    }\n    for (let i = 0; i < track.inner.length - 1; i++) {\n        const p1 = track.inner[i];\n        const p2 = track.inner[i + 1];\n        const dist = lineIntersection(x, y, x + Math.sin(angle) * rayLength, y - Math.cos(angle) * rayLength, p1.x, p1.y, p2.x, p2.y);\n        if (dist > 0 && dist < minDist) minDist = dist;\n    }\n    return minDist / rayLength;\n}\n\nfunction lineIntersection(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): number {\n    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (den === 0) return -1;\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);\n    }\n    return -1;\n}\n\nfunction pointInPolygon(point: Point, polygon: Point[]): boolean {\n    let isInside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n\n        const intersect = ((yi > point.y) !== (yj > point.y))\n            && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\nfunction isPointInsideTrack(car: Car, track: Track): boolean {\n    // Проверяем все 4 угла машины\n    for (const corner of car.getCorners()) {\n        if (!pointInPolygon(corner, track.outer) || pointInPolygon(corner, track.inner)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// --- Основная логика ---\nclass Game {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    track: Track;\n    cars: Car[] = [];\n    bestCar: Car | null = null;\n    populationSize: number = 1;\n    currentCarIndex: number = 0;\n    running: boolean = false;\n    animationId: number = 0;\n    generation: number = 1;\n    currentLevel: number = 1;\n    totalLaps: number = 0;\n    startTime: number = 0;\n    \n    constructor(canvas: HTMLCanvasElement) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d')!;\n        this.track = new Track(canvas.width, canvas.height, this.currentLevel);\n        this.initUI();\n    }\n\n    initUI() {\n        document.getElementById('start-btn')!.addEventListener('click', () => this.start());\n        document.getElementById('reset-btn')!.addEventListener('click', () => this.resetGame());\n    }\n    \n    start() {\n        if (this.running) return;\n        \n        document.getElementById('start-btn')!.style.display = 'none';\n        document.getElementById('reset-btn')!.style.display = 'inline-block';\n\n        this.resetGame(false); // Не сбрасываем localStorage при старте\n    }\n\n    resetGame(clearLocalStorage = true) {\n        this.running = false;\n        if(this.animationId) cancelAnimationFrame(this.animationId);\n\n        this.currentLevel = 1;\n        this.generation = 1;\n        this.totalLaps = 0;\n        this.startTime = Date.now();\n\n        if (clearLocalStorage) {\n            localStorage.removeItem(\"bestBrain_level\" + this.currentLevel);\n        }\n\n        this.track = new Track(this.canvas.width, this.canvas.height, this.currentLevel);\n        this.cars = this.createInitialPopulation();\n        this.currentCarIndex = 0;\n        \n        const storedBrain = localStorage.getItem(\"bestBrain_level\" + this.currentLevel);\n        if (storedBrain) {\n            console.log(\"Loading brain from localStorage for level\", this.currentLevel);\n            const bestBrain = JSON.parse(storedBrain);\n            this.cars[0].brain = bestBrain;\n            this.bestCar = this.cars[0];\n        }\n        \n        this.running = true;\n        this.animate();\n    }\n    \n    createInitialPopulation(): Car[] {\n        const cars: Car[] = [];\n        const startPos = this.getStartPosition();\n        for (let i = 0; i < this.populationSize; i++) {\n            cars.push(new Car(startPos.x, startPos.y, startPos.angle));\n        }\n        this.currentCarIndex = 0;\n        return cars;\n    }\n\n    nextGeneration() {\n        this.generation++;\n    \n        const bestCarOfLastGeneration = this.cars.reduce((a, b) => a.getFitness(this.track) > b.getFitness(this.track) ? a : b);\n\n        if (bestCarOfLastGeneration) {\n            this.bestCar = new Car(0,0,0, bestCarOfLastGeneration.brain); \n            localStorage.setItem(\"bestBrain_level\" + this.currentLevel, JSON.stringify(bestCarOfLastGeneration.brain));\n            \n            this.cars = this.createInitialPopulation();\n            \n            this.cars[0].brain = NeuralNetwork.replicate(bestCarOfLastGeneration.brain);\n            NeuralNetwork.mutate(this.cars[0].brain, 0.2);\n\n        } else {\n            this.cars = this.createInitialPopulation();\n        }\n        this.currentCarIndex = 0;\n    }\n    \n    animate() {\n        if (!this.running) return;\n\n        const currentCar = this.cars[this.currentCarIndex];\n        const lapCompleted = currentCar.update(this.track);\n\n        if (lapCompleted) {\n            this.running = false; // Pause the game\n            this.showLevelCompleteBanner(() => {\n                this.nextLevel(currentCar.brain);\n                this.running = true;\n                this.animate();\n            });\n            return; \n        }\n        \n        if (!currentCar.alive) {\n            this.currentCarIndex++;\n            if (this.currentCarIndex >= this.cars.length) {\n                this.nextGeneration();\n            }\n        }\n\n        this.updateUI();\n\n        this.render();\n        this.animationId = requestAnimationFrame(() => this.animate());\n    }\n    \n    getStartPosition(): { x: number, y: number, angle: number } {\n        if (this.currentLevel === 1) {\n            return { x: 170, y: 150, angle: 0 };\n        } else if (this.currentLevel === 2) {\n            return { x: 150, y: 150, angle: 0 };\n        }\n        throw new Error(\"Invalid level\");\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.renderTrack();\n\n        if (this.currentCarIndex >= this.cars.length) return;\n        const currentCar = this.cars[this.currentCarIndex];\n\n        this.ctx.save();\n        this.track.checkpoints.forEach((cp, index) => {\n            const nextCpIndex = currentCar.checkpointIndex % this.track.checkpoints.length;\n            \n            this.ctx.beginPath();\n            this.ctx.arc(cp.x, cp.y, cp.radius, 0, Math.PI * 2);\n            this.ctx.lineWidth = 2;\n            \n            if (index < currentCar.checkpointIndex) {\n                this.ctx.strokeStyle = \"rgba(0, 255, 0, 0.8)\";\n                this.ctx.fillStyle = \"rgba(0, 255, 0, 0.3)\";\n            } else if (index === nextCpIndex) {\n                this.ctx.strokeStyle = \"rgba(255, 255, 0, 1)\";\n                this.ctx.fillStyle = \"rgba(255, 255, 0, 0.4)\";\n            } else {\n                this.ctx.strokeStyle = \"rgba(255, 255, 255, 0.5)\";\n                this.ctx.fillStyle = \"rgba(255, 255, 255, 0.1)\";\n            }\n            this.ctx.stroke();\n            this.ctx.fill();\n            \n            this.ctx.fillStyle = \"white\";\n            this.ctx.font = \"12px Arial\";\n            this.ctx.textAlign = \"center\";\n            this.ctx.textBaseline = \"middle\";\n            this.ctx.fillText((index).toString(), cp.x, cp.y);\n        });\n        this.ctx.restore();\n\n        this.ctx.globalAlpha = 0.2;\n        this.cars.forEach(car => {\n            if (car.alive) this.renderCar(car)\n        });\n        this.ctx.globalAlpha = 1;\n\n        if (currentCar && currentCar.alive) {\n            this.renderCar(currentCar);\n        }\n    }\n\n    renderTrack() {\n        this.ctx.save();\n        this.ctx.strokeStyle = '#fff';\n        this.ctx.lineWidth = 5;\n        this.ctx.fillStyle = '#888'; // Цвет дороги\n\n        // Рисуем внешнюю и внутреннюю границы и заливаем пространство между ними\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.outer[0].x, this.track.outer[0].y);\n        for (const p of this.track.outer) {\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.closePath();\n\n        this.ctx.moveTo(this.track.inner[0].x, this.track.inner[0].y);\n        for (const p of this.track.inner) {\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.closePath();\n        \n        this.ctx.fill('evenodd');\n        \n        // Рисуем белые линии границ\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.outer[0].x, this.track.outer[0].y);\n        for (const p of this.track.outer) {\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.stroke();\n\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.track.inner[0].x, this.track.inner[0].y);\n        for (const p of this.track.inner) {\n            this.ctx.lineTo(p.x, p.y);\n        }\n        this.ctx.stroke();\n\n        // Рисуем стартовую линию\n        this.ctx.strokeStyle = '#fff';\n        this.ctx.lineWidth = 10;\n        this.ctx.setLineDash([10, 10]);\n        this.ctx.beginPath();\n        if (this.currentLevel === 1) {\n            this.ctx.moveTo(200, 100);\n            this.ctx.lineTo(200, 200);\n        } else if (this.currentLevel === 2) {\n            this.ctx.moveTo(150, 100);\n            this.ctx.lineTo(150, 200);\n        }\n        this.ctx.stroke();\n\n        this.ctx.restore();\n    }\n\n    renderCar(car: Car) {\n        this.ctx.save();\n        this.ctx.translate(car.x, car.y);\n        this.ctx.rotate(car.angle);\n        this.ctx.fillStyle = car.alive ? '#3498db' : '#e74c3c';\n        this.ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);\n        this.ctx.restore();\n    }\n    \n    updateUI() {\n        (document.getElementById('level') as HTMLElement).textContent = this.currentLevel.toString();\n        (document.getElementById('generation') as HTMLElement).textContent = this.generation.toString();\n        \n        const bestCarOfLastGeneration = this.cars.reduce((a, b) => a.getFitness(this.track) > b.getFitness(this.track) ? a : b);\n        (document.getElementById('best-score') as HTMLElement).textContent = bestCarOfLastGeneration.getFitness(this.track).toFixed(0);\n        \n        if (this.currentCarIndex < this.cars.length) {\n            const currentCar = this.cars[this.currentCarIndex];\n            if (currentCar) {\n                (document.getElementById('score') as HTMLElement).textContent = currentCar.getFitness(this.track).toFixed(0);\n            }\n        }\n\n        (document.getElementById('laps-completed') as HTMLElement).textContent = this.totalLaps.toString();\n        const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);\n        (document.getElementById('total-time') as HTMLElement).textContent = `${elapsedTime}с`;\n    }\n\n    showLevelCompleteBanner(callback: () => void) {\n        const banner = document.getElementById('level-complete-banner')!;\n        banner.style.display = 'block';\n        setTimeout(() => {\n            banner.style.display = 'none';\n            callback();\n        }, 3000); // Show for 3 seconds\n    }\n\n    nextLevel(fittestBrain: NeuralNetwork) {\n        this.totalLaps++;\n        this.currentLevel++;\n        this.generation = 1;\n\n        if (this.currentLevel > 2) { \n            alert(\"Поздравляем! Вы прошли все уровни!\");\n            this.resetGame(true);\n            return;\n        }\n\n        localStorage.setItem(\"bestBrain_level\" + this.currentLevel, JSON.stringify(fittestBrain));\n\n        this.track = new Track(this.canvas.width, this.canvas.height, this.currentLevel);\n        this.cars = this.createInitialPopulation();\n        this.cars[0].brain = NeuralNetwork.replicate(fittestBrain);\n        NeuralNetwork.mutate(this.cars[0].brain, 0.3);\n\n        this.currentCarIndex = 0;\n        this.bestCar = this.cars[0];\n    }\n}\n\n// --- Запуск ---\ndocument.addEventListener('DOMContentLoaded', () => {\n    const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;\n    if (canvas) {\n        const game = new Game(canvas);\n    }\n});\n"],"names":["$ad2bcec7a0192558$var$NeuralNetwork","neuronCounts","levels","i","length","push","$ad2bcec7a0192558$var$Level","feedForward","givenInputs","network","outputs","replicate","newNetwork","map","l","inputs","concat","biases","weights","w","mutate","amount","forEach","level","a","b","Math","random","j","inputCount","outputCount","Array","from","splice","sum","$ad2bcec7a0192558$var$Track","width","height","outer","inner","checkpoints","generateTrack","generateCheckpoints","x","y","radius","$ad2bcec7a0192558$var$Car","angle","brain","alive","score","timeAlive","checkpointIndex","laps","maxSpeed","speed","update","track","nextCp","distToCp","hypot","angleToCp","atan2","carAngleRelativeToCp","PI","turn","cos","sin","checkCollision","checkCheckpoints","$ad2bcec7a0192558$var$isPointInsideTrack","car","corner","getCorners","$ad2bcec7a0192558$var$pointInPolygon","getFitness","nextCpIndex","prevCpIndex","prevCp","totalCpDist","progress","max","fitness","rad","alpha","p1","p2","point","polygon","isInside","xi","yi","xj","yj","intersect","$ad2bcec7a0192558$var$Game","canvas","cars","bestCar","populationSize","currentCarIndex","running","animationId","generation","currentLevel","totalLaps","startTime","ctx","getContext","initUI","document","getElementById","addEventListener","start","resetGame","style","display","clearLocalStorage","cancelAnimationFrame","Date","now","localStorage","removeItem","createInitialPopulation","storedBrain","getItem","console","log","bestBrain","JSON","parse","animate","startPos","getStartPosition","nextGeneration","bestCarOfLastGeneration","reduce","setItem","stringify","currentCar","showLevelCompleteBanner","nextLevel","updateUI","render","requestAnimationFrame","Error","clearRect","renderTrack","save","cp","index","beginPath","arc","lineWidth","strokeStyle","fillStyle","stroke","fill","font","textAlign","textBaseline","fillText","toString","restore","globalAlpha","renderCar","p","moveTo","lineTo","closePath","setLineDash","translate","rotate","fillRect","textContent","toFixed","elapsedTime","floor","callback","banner","setTimeout","fittestBrain","alert"],"version":3,"file":"macqueen.a508ab36.js.map"}